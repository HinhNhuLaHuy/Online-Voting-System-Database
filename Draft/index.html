<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="addDescription" id="addDescription" style="display: block;">
        <button class="addDescriptionButton" id="addDescriptionButton" onclick="myFunction()">
            <svg class="h-5 w-5 " xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20" stroke="">
                <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd"></path>
            </svg>
            <span class="addDescriptionSpan">Add description</span>
        </button>
    </div>
        
        
    <div class="showDescription" id="showDescription" style="display: none;">
        <div>
            <label for="description" class="label">
                Description
                <span class="optional">
                    (optional)
                </span>
            </label>
        </div>
        <div class="showDescriptionBox">
            <textarea id="description" name="description" rows="3" class="descriptionText"></textarea>
        </div>
    </div>
        
        <script>
            function myFunction() {
                var x = document.getElementById('addDescription');
                var y = document.getElementById('showDescription');
                
                var displayAdd = x.style.display;
                var displayDescription = y.style.display;
                
                if (displayAdd == "block") {
                    x.style.display = "none";
                    y.style.display = "block";
                }
            } 
        </script>


















function createPoll() {
    return {
        showDescription: false,
        poll: {
            type: 'multiple_choice',
            title: '',
            pollMeta: {
                description: null,
                location: null,
                timezone: null
            },
            media: { path: null },
            theme: null,
            pollOptions: [
                { value: '', type: 'text', media: null, maxVotes: 0 },
                { value: '', type: 'text', media: null, maxVotes: 0 }
            ],
            pollConfig: {
                isPrivate: true,
                isMultipleChoice: false,
                multipleChoiceMin: null,
                multipleChoiceMax: null,
                requireVoterNames: false,
                duplicationChecking: 'ip',
                deadlineAt: null,
                allowComments: false,
                allowOtherOption: false,
                allowVpnUsers: false,
                hideParticipants: false,
                editVotePermissions: 'nobody',
                resultsVisibility: 'always',
                allowIndeterminate: false,
                voteType: 'default',
                showWriteInOptions: false,
                layout: null,
            },
            status: 'published',
        },
        titleError: false,
        createError: null,
        pasteAnswerOptions: false,
        pasteAnswerContent: '',
        dateSelection: [],
        anonymousVoting: true,
        multipleChoiceType: 'unlimited',
        hasCustomTimezone: false,
        limitSingleOption: false,
        hasDeadline: false,
        hasResultsHidden: false,
        isLoadingCreate: false,
        action: 'create',
        optionsType: 'text',
        init() {
            this.updateSettings()

            if (this.$store.poll.id) {
                this.poll = JSON.parse(JSON.stringify(this.$store.poll))
            }

                if (this.$store.user.userConfig.defaultThemeId) {
                    this.poll.theme = { id: this.$store.user.userConfig.defaultThemeId }
                }

                if (this.$store.user.userConfig.defaultWorkspaceId) {
                    this.poll.workspace = { id: this.$store.user.userConfig.defaultWorkspaceId }
                }

            this.$refs.titleInput.focus()


            this.$watch('poll.type', value => {
                this.updateSettings()
                if (value === 'meeting') {
                    this.optionsType = 'dates'
                }
            })

            this.$watch('hasCustomTimezone', value => { 
                if (value) {
                    this.poll.pollMeta.timezone = strawpoll.getTimezone()
                } else {
                    this.poll.pollMeta.timezone = null
                } 
            })

            this.$watch('limitSingleOption', value => {
                if (value) {
                    this.multipleChoiceType = 'exact'
                    this.poll.pollConfig.isMultipleChoice = true
                    this.poll.pollConfig.multipleChoiceMin = 1
                    this.poll.pollConfig.multipleChoiceMax = 1
                } else {
                    this.multipleChoiceType = 'unlimited'
                    this.poll.pollConfig.isMultipleChoice = true
                    this.poll.pollConfig.multipleChoiceMin = 0
                    this.poll.pollConfig.multipleChoiceMax = 0
                }
            })
        },
        updateSettings() {
            if (this.poll.type === 'multiple_choice') {
                this.poll.pollConfig.requireVoterNames = false
                this.poll.pollConfig.duplicationChecking = 'ip'
                this.poll.pollConfig.allowVpnUsers = false
                this.poll.pollConfig.isMultipleChoice = false
                this.poll.pollConfig.voteType = 'default'
                this.poll.pollConfig.editVotePermissions = 'nobody'
                this.poll.pollConfig.allowIndeterminate = false
                this.poll.pollConfig.allowComments = false
                this.poll.pollConfig.layout = null
            } else if (this.poll.type === 'image_poll') {
                this.poll.pollConfig.requireVoterNames = false
                this.poll.pollConfig.duplicationChecking = 'ip'
                this.poll.pollConfig.allowVpnUsers = false
                this.poll.pollConfig.isMultipleChoice = false
                this.poll.pollConfig.voteType = 'default'
                this.poll.pollConfig.editVotePermissions = 'nobody'
                this.poll.pollConfig.allowIndeterminate = false
                this.poll.pollConfig.allowComments = false
                this.poll.pollConfig.layout = 'grid'
            } else if (this.poll.type === 'meeting') {
                this.poll.pollConfig.requireVoterNames = true
                this.poll.pollConfig.duplicationChecking = 'none'
                this.poll.pollConfig.allowVpnUsers = true
                this.poll.pollConfig.isMultipleChoice = true
                this.poll.pollConfig.voteType = 'participant_grid'
                this.poll.pollConfig.editVotePermissions = 'admin_voter'
                this.poll.pollConfig.allowIndeterminate = true
                this.poll.pollConfig.allowComments = true
                this.poll.pollConfig.layout = null
            }
        },
        updatePoll() {
            poll = this.$event.detail.poll
            if ( this.$event.detail.convertOptions) {
                this.convertOptionsToDates()
            }
        },
        addAnswerOption(i) {
            if (this.poll.pollOptions.length >= 500) {
                return
            }

            this.poll.pollOptions.splice(i+1, 0, { value: '' })
            this.$nextTick(() => { document.getElementById('option-'+(i+1)).focus() })
        },
        removeAnswerOption(i) {
            this.poll.pollOptions.splice(i, 1);
        },
        openPasteAnswerOptions() {
            if (this.poll.pollOptions[0].value) {
                this.pasteAnswerContent = this.poll.pollOptions.map((pollOption) => pollOption.value).join("\n")
            }
            this.pasteAnswerOptions = true
        },
        parsePasteAnswerOptions() {
            const answers = this.pasteAnswerContent.split("\n");

            this.poll.pollOptions = []

            answers.forEach((answer) => {
                answer = answer.replace(/^[\t\s]+/, '')
                answer = answer.replace(/[\t\s]+$/, '')
                if (answer) {
                    this.poll.pollOptions.push({ value: answer })
                }
            })

            while (this.poll.pollOptions.length < 2) {
                this.poll.pollOptions.push({ value: '' })
            }

            this.pasteAnswerOptions = false
            this.pasteAnswerContent = ''
        },
        async submitForm(type) {
            this.titleError = false
            this.createError = false

            if (type && type === 'draft') {
                this.poll.status = 'draft'
            }

            if (this.poll.title === '') {
                this.titleError = true
                this.$refs.titleInput.focus()
                return
            }

            // console.log(this.poll)

            if (this.poll.type === 'meeting') {
                this.poll.pollOptions = this.convertDatesToOptions()
            }

            this.poll.pollOptions.forEach((option) => {
                if (this.poll.type === 'multiple_choice') {
                    option.type = 'text'
                }

                if (this.poll.type === 'image_poll') {
                    option.type = 'image'
                }

                if (option.type === 'text') {
                    option.value = option.value.replace(/^[\t\s]+/, '')
                    option.value = option.value.replace(/[\t\s]+$/, '')
                }
            })

            if (this.poll.type === 'multiple_choice') {
                if (!this.poll.pollOptions[0] || !this.poll.pollOptions[1] || !this.poll.pollOptions[0].value || !this.poll.pollOptions[1].value) {
                    this.createError = 'Please enter at least two answer options.'
                    setTimeout(() => { this.createError = null }, 3000)
                    return
                }
            } else if (this.poll.type === 'image_poll') {
                if (!this.poll.pollOptions[0] || !this.poll.pollOptions[0].media || !this.poll.pollOptions[1].media) {
                    this.createError = 'Please enter at least two answer options.'
                    setTimeout(() => { this.createError = null }, 3000)
                    return
                }
            } else if (this.poll.type === 'meeting') {
                if (!this.poll.pollOptions[0]) {
                    this.createError = 'Please enter at least one answer option.'
                    setTimeout(() => { this.createError = null }, 3000)
                    return
                }
            }

            if (this.poll.pollConfig.isMultipleChoice) {
                if (this.multipleChoiceType === 'unlimited') {
                    this.poll.pollConfig.multipleChoiceMin = 0
                    this.poll.pollConfig.multipleChoiceMax = 0
                } else {
                    if (this.poll.pollConfig.multipleChoiceMin < 1) {
                        this.poll.pollConfig.multipleChoiceMin = 1 
                    }
                    if (this.poll.pollConfig.multipleChoiceMax < 1) {
                        this.poll.pollConfig.multipleChoiceMax = 1 
                    }
                    if (this.multipleChoiceType === 'exact') {
                        this.poll.pollConfig.multipleChoiceMin = this.poll.pollConfig.multipleChoiceMax
                    }
                    if (this.poll.pollConfig.multipleChoiceMin > this.poll.pollConfig.multipleChoiceMax) {
                        this.poll.pollConfig.multipleChoiceMin = this.poll.pollConfig.multipleChoiceMax
                    }
                }
            }

            this.isLoadingCreate = true
            
            let response = { error: null }
                
            if (this.action === 'create') {
                response = await strawpoll.fetchAPI('/polls', {
                    method: 'POST',
                    body: JSON.stringify(strawpoll.toSnakeCaseKeys(this.poll))
                })
            } else if (this.action === 'edit') {
                response = await strawpoll.fetchAPI('/polls/'+this.poll.id, {
                    method: 'PUT',
                    body: JSON.stringify(strawpoll.toSnakeCaseKeys(this.poll))
                })
            }

            if (!response.error) {
                if (response.status === 'draft') {
                    window.location.href = '/account/'
                } else {
                    window.location.href = response.path
                }
                this.isLoadingCreate = false
            } else {
                this.isLoadingCreate = false
            }
        },
        convertDatesToOptions() {
            if (this.optionsType !== 'dates') {
                return this.poll.pollOptions
            }

            const options = []

            console.log(this.dateSelection)

            this.dateSelection.forEach((date) => {
                if (date.times && date.times.length > 0) {
                    date.times = date.times.sort((a,b) => a.start - b.start)

                    date.times.forEach((time) => {
                        const startTime = this.changeTimezone(new Date(this.timestringToEpoch(date.date, time.start) * 1000), this.poll.pollMeta.timezone, strawpoll.getTimezone()).getTime() / 1000
                        const endTime = this.changeTimezone(new Date(this.timestringToEpoch(date.date, time.end) * 1000), this.poll.pollMeta.timezone, strawpoll.getTimezone()).getTime() / 1000

                        options.push({
                            id: time.id || this.randomId(),
                            type: 'time_range',
                            startTime: startTime,
                            endTime: endTime,
                            position: options.length,
                            maxVotes: date.maxVotes || 0,
                        })
                    })
                } else {						
                    options.push({
                        id: date.id || this.randomId(),
                        type: 'date',
                        date: dayjs(date.date).format('YYYY-MM-DD'),
                        position: options.length,
                        maxVotes: date.maxVotes || 0,
                    })
                }
            })

            return options
        },
        convertOptionsToDates() {
            this.dateSelection = []

            this.poll.pollOptions.forEach((option) => {
                let date = null

                if (option.type === 'text') {
                    return
                }

                if (option.type === 'date') {
                    date = new Date(option.date + 'T00:00:00')
                } else if (option.type === 'time_range') {
                    const startDate = this.changeTimezone(new Date(option.startTime * 1000), strawpoll.getTimezone(), this.poll.pollMeta.timezone)
                    date = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0)
                }

                let dIndex = this.dateSelection.findIndex(e => e.date.getTime() === date.getTime())

                if (dIndex === -1) {
                    const length = this.dateSelection.push({
                        id: option.id,
                        date: date,
                        maxVotes: option.maxVotes,
                        times: []
                    })

                    dIndex = length - 1
                }

                if (option.type === 'time_range') {
                    const startTimestring = this.dateToTimestring(this.changeTimezone(new Date(option.startTime * 1000), strawpoll.getTimezone(), this.poll.pollMeta.timezone))
                    const endTimestring = this.dateToTimestring(this.changeTimezone(new Date(option.endTime * 1000), strawpoll.getTimezone(), this.poll.pollMeta.timezone))

                    this.dateSelection[dIndex].times.push({
                        id: option.id,
                        start: startTimestring, 
                        end: endTimestring,
                        seconds: this.timestringToSeconds(startTimestring),
                        maxVotes: option.maxVotes,
                        global: false
                    })
                }
            })

            this.dateSelection.forEach((d) => {
                if (d.times.length > 0) {
                    d.times = d.times.sort((a,b) => a.seconds - b.seconds)
                }
            })

            this.dateSelection = this.dateSelection.sort((a,b) => a.date.getTime() - b.date.getTime())
        },
        randomId() {
            return Math.random().toString(36).slice(2)
        },
        changeTimezone(date, tz, oldTz) {
            if (!tz && !this.poll.pollMeta.timezone) return date
            
            if (!tz) {
                tz = this.poll.pollMeta.timezone
            }

            if (!oldTz) {
                oldTz = strawpoll.getTimezone()
            }

            let invdate = new Date(date.toLocaleString('en-US', {
                timeZone: tz
            }))

            let oldInvdate = new Date(date.toLocaleString('en-US', {
                timeZone: oldTz
            }))

            let diff = oldInvdate.getTime() - invdate.getTime()

            return new Date(date.getTime() + diff)
        },
        timestringToSeconds(timestring) {
            let a = timestring.split(':')
            return parseInt(a[0]) * 3600 + parseInt(a[1]) * 60 
        },
        secondsToHMS(seconds) {
            var hours   = Math.floor(seconds / 3600)
            var minutes = Math.floor(seconds / 60) % 60
            var seconds = seconds % 60
            
            return [hours, minutes, seconds]
        },
        secondsToTimestring(seconds) {
            var hours = ('0' + Math.floor(seconds % (3600 * 24) / 3600)).slice(-2)
            var minutes = ('0' + Math.floor(seconds % 3600 / 60)).slice(-2)

            return hours+':'+minutes
        },
        dateToTimestring(date) {
            var hours = ('0' + date.getHours()).slice(-2)
            var minutes = ('0' + date.getMinutes()).slice(-2)

            return hours+':'+minutes
        },
        timestringToEpoch(date, timestring) {
            const seconds = this.timestringToSeconds(timestring)
            const HMS = this.secondsToHMS(seconds)
            date.setHours(HMS[0])
            date.setMinutes(HMS[1])
            date.setSeconds(HMS[2])
            return date.getTime() / 1000
            // return new Date(date.getTime() + seconds * 1000).getTime() / 1000
        },
    }
}

</body>
</html>